---
title: Building an animated COVID-19 tracker in Vue.js
date: 2020-05-08
description: transform-when is a library I wrote at SamKnows that allows you to combine a number of variables—scroll position, time, and user actions—to create beautiful, performant animations. This article demonstrates some of the functionality of the library.
---

goals:

- intro to svg in vuejs
- intro to animating svg in vuejs
- a bit of data visualisation theory

## Introduction

The following is an article version of a few talks I've given with the title "Data Visualisation in Vue.js"

If you've been on the internet in the last months or so, there's a good chance you'll have seen a visualisation that looked something like this:

@todo insert tweet

I've been working with data visualisation using only Vue.js for a while now, so I wanted to see if I could implement it in Vue without using any other libraries.

Vue is most commonly used to manipulate HTML, but did you know that you can use it to directly work with SVG elements?

SVG is an image format that can be used to generate vector graphics, such as 2D shapes and lines. It's commonly used for icons and simple graphics—SVG images are significantly smaller than their PNG and JPEG counterparts. While it's typically generated by a graphics editors such as Illustrator, Sketch or Figma, they're XML-based which means that it's also possible to write them by hand—or programmatically using code. Common libraries to do this include D3, Highcharts, and Chartist, but it's actually possible to use Vue.js to generate and manipulate SVGs directly!

## A quick SVG primer

Let's take a brief look at how you can write SVGs by hand without using any JavaScript at all. If you're familiar with SVGs, feel free to skip this section.

To write SVG directly into an HTML document, you can use the `<svg>` tag, like so:

```html
<svg
  width="400" height="250"
  xmlns="http://www.w3.org/2000/svg">
</svg>
```

When you load your page, you'll see something like this:

<svg width="400" height="250" xmlns="http://www.w3.org/2000/svg" style="border: 1px rgba(41, 61, 163, 0.2) solid;">
</svg>

As you can see, it's a blank rectangle. I added the border to make it clearer, but usually you wouldn't see that either. This is our blank canvas; our space to draw!

Let's start by adding a rectangle using the `<rect>` element:

```html
<svg
  width="400" height="250"
  xmlns="http://www.w3.org/2000/svg">
  <rect
    width="200" height="100"
    x="50" y="50"
    fill="hsl(10, 80%, 70%)"
  />
</svg>
```

We've passed the element five attributes, telling it how big it should be (`width` and `height`), where it should display in the SVG element (`x` and `y`—positioned from the top left), and what it should look like (the `fill` attribute).

This is the output:

<svg width="400" height="250" xmlns="http://www.w3.org/2000/svg" style="border: 1px rgba(41, 61, 163, 0.2) solid;">
<rect width="200" height="100" x="50" y="50" fill="hsl(10, 80%, 70%)" />
</svg>

It'll have become clear by now that SVG is a pretty different language to HTML—while you can write it directly in an HTML document, nearly everything about it is different other than the fact that they have similar syntaxes. While elements in HTML documents are by default displayed one after the other in the order they appear, SVG elements generally have to be told where to display, or they'll appear at the top left, overlapping one another. The way we style SVG elements are also different—while with HTML we use CSS with properties like `background-color` and `border` to style rectangular elements, in SVG we style shapes using attributes like `fill`, `stroke`, and `stroke-width`.

Some of these differences are simply because HTML and SVG are two different languages, but some of the differences are what makes SVG so good for vector-based images compared to HTML.

The other thing we'll need for our visualisation is some text. To add text, we use the appropriately named `<text>` element:

```html
<svg
  width="400" height="250"
  xmlns="http://www.w3.org/2000/svg">
  <rect
    width="200" height="100"
    x="50" y="50"
    fill="hsl(10, 80%, 70%)"
  />
  <text x="50" y="50">Some text</text>
</svg>
```

Which outputs: 

<svg width="400" height="250" xmlns="http://www.w3.org/2000/svg" style="border: 1px rgba(41, 61, 163, 0.2) solid;">
<rect width="200" height="100" x="50" y="50" fill="hsl(10, 80%, 70%)" />
<text x="50" y="50">Some text</text>
</svg>

There are three things to note here:

- The `<text>` element isn't a child of the `<rect>` element like it usually would be in an HTML document. The `<rect>` element can _only_ be used to output the shape, and cannot be used to position anything inside it. There is an element we can use to do this which we will look at later.
- The text is displaying above the rectangle, not inside it. This is because by default, text is positioned so that the baseline of the text lies on the point specified by `x` and `y`. This is configurable with the `alignment-baseline` attribute, which again, we will be looking at later.
- While text inside the SVG element inherits font size and font family from the document, it doesn't inherit the colour. This is because the CSS I've applied to the body element of this website is also inherited by the elements inside the SVG, and we _can_ style SVGs using CSS—it just works slightly differently to styling HTML elements with CSS.

### Grouping SVG elements

In the example above, the rectangle and text elements are direct children of the SVG element—but what if we have multiple rectangles each with some text associated with them? We could have a `rect` followed by a `text` followed by a `rect`, by a `text`, etc, but that's not especially nice—especially when we want to start looping through data in Vue.

SVG has an element for grouping other elements, kind of similar to HTML's `<div>` element. Here's how we use it:

```html
<svg
  width="400" height="250"
  xmlns="http://www.w3.org/2000/svg">
    <g transform="translate(50, 50)">
    <rect
      width="200" height="100"
      fill="hsl(10, 80%, 70%)"
    />
    <text>Some text</text>
  </g>
</svg>
```

This outputs exactly the same as the example above that used `x` and `y`, but without the duplication of the positions as the `transform` is also being applied to the elements within the group. Note that the group element doesn't accept `x` and `y` attributes: you have to use a transform to translate the group instead.

Now that we've freed up the `x` and `y` attributes of the text, let's use it to position the text in the centre of the rectangle:

```html
<svg
  width="400" height="250"
  xmlns="http://www.w3.org/2000/svg">
  <g transform="translate(50, 50)">
    <rect
      width="200" height="100"
      fill="hsl(10, 80%, 70%)"
    />
    <text
      x="100" y="50"
      alignment-baseline="middle"
      text-anchor="middle">
      Some text
    </text>
  </g>
</svg>
```

Here's the output:

<svg
width="400" height="250"
xmlns="http://www.w3.org/2000/svg" style="border: 1px rgba(41, 61, 163, 0.2) solid;">
<g transform="translate(50, 50)">
<rect
width="200" height="100"
fill="hsl(10, 80%, 70%)"
/>
<text
x="100" y="50"
alignment-baseline="middle"
text-anchor="middle">
Some text
</text>
</g>
</svg>

Okay, so there's a couple things going on here including two new attributes. First, note that the x and y positions of the text are set to half the width and height of the rectangle. That means that the text will be positioned from the centre of the rectangle. By default, though, that would result in the text appearing in the upper right of the rectangle, like this:

<svg
width="400" height="250"
xmlns="http://www.w3.org/2000/svg" style="border: 1px rgba(41, 61, 163, 0.2) solid;">
<g transform="translate(50, 50)">
<rect
width="200" height="100"
fill="hsl(10, 80%, 70%)"
/>
<text x="100" y="50">
Some text
</text>
</g>
</svg>

The two attributes added in the last example help us here. `alignment-baseline` says where the text should be positioned vertically by specifying which baseline of the element should be used. `text-anchor` does a similar thing, but horizontally instead of vertically.

Here's a quick demo:

@todo WHY ISN'T ALIGNMENT BASELINE WORKING!

<div id="text-position-demo">
<p>
<small>
alignment-baseline:
<select v-model="baselineSelect.value">
<option v-for="option in baselineSelect.options">{{ option }}</option>
</select>
<span style="margin-left: 1em">text-anchor:</span>
<select v-model="textAnchorSelect.value">
<option v-for="option in textAnchorSelect.options">{{ option }}</option>
</select>
</small>
</p>
<svg
width="400" height="250"
xmlns="http://www.w3.org/2000/svg" style="border: 1px rgba(41, 61, 163, 0.2) solid;">
<g transform="translate(50, 50)">
<rect
width="200" height="100"
fill="hsl(10, 80%, 70%)"
/>
<text
x="100" y="50"
:alignment-baseline="baselineSelect.value"
:text-anchor="textAnchorSelect.value">
Some text
</text>
</g>
<path d="M 0 100 L 400 100 M 150 0 L 150 250" stroke="rgba(41, 61, 163, 0.2)" stroke-width="1" />
<circle cx="150" cy="100" r="2" fill="red" />
</svg>
</div>

Don't ask me what all the possible values for alignment-baseline do - I have no idea!

### CSS and SVG

As I mentioned previously, you can style SVGs using CSS, but it works in quite a different way to styling HTML using CSS.

The selector logic is (mostly) the same, but the actual declarations are different. `color: red` won't do anything if you apply it to an SVG element. Instead, the declarations you write in the CSS are the same as the attributes you provide directly to the elements.

It's easier understood with an example:

```css
svg > text {
  x: 100;
  y: 50;
  alignment-baseline: middle;
  text-anchor: middle
}
```

That's the equivalent of writing `x="100" y="50" alignment-baseline="middle" text-anchor="middle"` on every text element inside the SVG element. I tend to use this for styling stuff—`alignment-baseline` and `text-anchor`—but keep the positioning attributes directly on the SVG elements.

So that's a super quick tour of SVG. For a longer read that goes more into depth into all the features of SVGs, I'm a big fan of the [SVG tutorial on MDN](https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial).

Let's start looking at our COVID-19 visualisation.

## Getting the data

The first part of any data visualisation project is often also the most challenging——getting the data!

In this case, it's not too tricky—a lot of the existing media coverage cites John Hopkins University as a source, and a quick search finds [this GitHub repository](https://github.com/CSSEGISandData/COVID-19) by the Center of System Science and Engineering at John Hopkins.

Now that we've found that, it's a case of working what data in there we want to visualise—I'm using `time_series_covid19_confirmed_global.csv`—and transforming the data into the exact data we want to visualise. In this case, I want to visualise the data by country, not by region, so I've got some logic to add the total up for each country.

@todo link to logic

The end result can be found @todo

## Building a static chart

So now that we have our data, let's look at how we can use Vue to connect up what we've learned about SVGs so far and the data we've fetched to create a static chart.

Let's start by creating a Vue instance with some mock data in, so that we can make sure the chart works before we add the real dataset (which is considerably larger) in.

```javascript
const data = {
  dates: ['1/22/20', '2/11/20', '3/27/20'],
  countryData: {
    China: [548, 44386, 81897],
    'United States': [1, 11, 101657]
  }
};

new Vue({
  data: () => ({
    day: 2
  })
});
```

This is a tiny subset of the data: three days worth of data in two countries. As the final dataset isn't _that_ big—it's not like we have to wait two hours for the visualisation to render—it doesn't have to be perfect and we don't have to test all cases before giving it all the data. We just have to make sure that _something_ is displayed.

Note that we're storing the data in an object outside of the Vue instance. This means that anything we add consuming that data won't be reactive, but that's okay—that object declaration is eventually going to turn into an `import` statement to get the JSON file anyway.

We're aiming to display the number of cases in each country on a given day, so we want to transform the data to something like this:

```json
[
  { "country": "China", "value": 81897 },
  { "country": "United States", "value": 101657 }
]
```

Let's add a `chartData` computed property that looks at the `day` and `countryData` and returns just that:

```javascript
computed: {
  chartData() {
    return Object.entries(data.countryData)
      .map(([country, dataArray]) => {
        return {
          country,
          value: dataArray[this.day]
        };
      })
      .filter(({ value }) => value);
  }
}
```

When we get to animating the chart, Vue's reactivity means that if we modify `this.day`, the data returned by `this.chartData` will be updated as well.

For now though, we've got enough to move to the template and start displaying some stuff on screen.

## Animating the chart

Talk about properties that are animatable in CSS vs SVG
